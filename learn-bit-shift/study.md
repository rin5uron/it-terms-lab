# シフト演算の解説構成（最終構成案）

---

## ① シフト演算とは？

シフト演算とは、**2進数のビット（桁）を左右にずらすことで、2の累乗による掛け算・割り算をシンプルかつ高速に行う演算**です。

---

## ② 10進数で考えてみる（直感づくり）

```
123 << 1 → 1230（×10）
123 >> 1 → 12.3（÷10）

→ 桁をずらすことで、10倍・10分の1になる
```

この「桁をずらす＝何倍・何分の1」という感覚を、  
**2進数の世界でも同じように応用する**のが「シフト演算」です。

---

## ③ 2進数でのシフト演算

> ※ ここで「このしくみは **2進数だからこそ**成り立つ」ということを説明！

---

## ④ 論理シフト（Logical Shift）

**→ 左右にずらしたときに、空いた桁に「0」を詰める方法。**

📌 正の整数・非負整数で使われ、**左シフトで×2、右シフトで÷2** になる。

### 🔹 例：論理シフトの対応表

| 操作         | 2進数の変化             | 結果（10進数） | 解説             |
|--------------|--------------------------|----------------|------------------|
| 5 << 1       | 00000101 → 00001010      | 10             | ×2（左に1ビット） |
| 5 << 2       | 00000101 → 00010100      | 20             | ×4（左に2ビット） |
| 8 >> 1       | 00001000 → 00000100      | 4              | ÷2（右に1ビット） |
| 8 >> 2       | 00001000 → 00000010      | 2              | ÷4（右に2ビット） |

※ 左端には常に **0が入る**  
※ 負の数には対応していない

---

## ⑤ 算術シフト（Arithmetic Shift）

**→ 左端の符号ビットを固定したまま右シフトする方法。**

- 負の数もそのまま扱える
- CPUレベルでは「符号付き整数（signed int）」に使われる

### 🔹 例（符号付き8ビット）

```
-4（11111100） >> 1 → 11111110（= -2）
```

→ 左端の 1（負の符号）を保って右にずらす

---

## ⑥ 補足：オーバーフロー（左シフトでも負になることがある）

> 左シフトでも、**最上位ビットに1が入ると符号が変わる**

### 例：

```
64（01000000） << 1 → 10000000（= -128）
```

→ 左シフトでも負になる！これは **桁あふれ（オーバーフロー）** によるもの

---

## ⑦ 注意書き（進数とシフト演算）

シフト演算は、**2進数のビットを直接操作する演算**で、  
主に **CPU内部や低レイヤー処理**で使われます。

8進数や16進数では **表記を簡略化する目的で使われることはあります**が、  
**演算自体は常に2進数に戻して処理されます。**
