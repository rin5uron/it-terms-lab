# シフト演算の解説構成（最終構成案）

---

## ① シフト演算とは？

シフト演算とは、**2進数のビット（桁）を左右にずらすことで、2の累乗による掛け算・割り算をシンプルかつ高速に行う演算**です。

---

## ② 10進数で考えてみる

```
123 << 1 → 1230（×10）
123 >> 1 → 12.3（÷10）

→ 桁をずらすことで、10倍・10分の1になる
```

この「桁をずらす＝何倍・何分の1」という感覚を、  
**2進数の世界でも同じように応用する**のが「シフト演算」です。

---

## ③ 2進数でのシフト演算

シフト演算が「2の累乗による掛け算・割り算」として機能するのは、**2進数だからこそ**成り立ちます。
10進数では桁をずらすと10倍・10分の1になるように、2進数では桁をずらすと2倍・2分の1になります。
これは、各桁の重みが2の累乗で表現される2進数の特性によるものです。

---

## ④ 論理シフト（Logical Shift）

**→ 桁を左右にずらし、空いた桁に「0」を詰める方法。**

📌 主に正の整数・非負整数で使われ、**左シフトで×2、右シフトで÷2** になります。

### 🔹 例：論理シフト（8ビット表現）

```
# 左シフト (<<): 空いた桁に0を詰める
# 5 (0000 0101) を1ビット左シフト
元の値:  0 0 0 0  0 1 0 1  (5)
左シフト: 0 0 0 0  1 0 1 0  (10)  <- 右端に0が追加される

# 5 (0000 0101) を2ビット左シフト
元の値:  0 0 0 0  0 1 0 1  (5)
左シフト: 0 0 0 1  0 1 0 0  (20)  <- 右端に0が2つ追加される

# 右シフト (>>): 空いた桁に0を詰める
# 8 (0000 1000) を1ビット右シフト
元の値:  0 0 0 0  1 0 0 0  (8)
右シフト: 0 0 0 0  0 1 0 0  (4)   <- 左端に0が追加される

# 8 (0000 1000) を2ビット右シフト
元の値:  0 0 0 0  1 0 0 0  (8)
右シフト: 0 0 0 0  0 0 1 0  (2)   <- 左端に0が2つ追加される
```

※ 論理右シフトでは、常に左端に **0** が入ります。
※ 負の数には対応していません。

---

## ⑤ 算術シフト（Arithmetic Shift）

**→ 左端の符号ビットを固定したまま右シフトする方法。**

- 負の数もそのまま扱えるため、符号付き整数の除算によく用いられます。
- CPUレベルでは「符号付き整数（signed int）」の演算に使われます。

### 🔹 例：算術右シフト（符号付き8ビット表現）

```
# 負の数 -4 (1111 1100) を1ビット算術右シフト
# 符号ビット (一番左のビット) は維持される
元の値:  1 1 1 1  1 1 0 0  (-4)
右シフト: 1 1 1 1  1 1 1 0  (-2)  <- 符号ビットの1が左端に複製される
```

---

## ⑥ 補足：オーバーフロー（左シフトでも負になることがある）

> 左シフトでも、**最上位ビットに1が入ると符号が変わる**

### 例：

```
# 64 (0100 0000) を1ビット左シフト
元の値:  0 1 0 0  0 0 0 0  (64)
左シフト: 1 0 0 0  0 0 0 0  (-128) <- 最上位ビットが1になり、符号が反転
```

→ 左シフトでも負になる！これは **桁あふれ（オーバーフロー）** によるものです。

---

## ⑦ 注意書き（進数とシフト演算）

シフト演算は、**2進数のビットを直接操作する演算**で、  
主に **CPU内部や低レイヤー処理**で使われます。

8進数や16進数では **表記を簡略化する目的で使われることはあります**が、  
**演算自体は常に2進数に戻して処理されます。**


---

## ⚠️ 補足：左シフトでも負になることがある（オーバーフロー）

左シフトは通常「×2」「×4」のように値を大きくしますが、  
**符号付きの整数を左シフトして、最上位ビットに1が入ると、**  
**符号が反転して“負の数”として扱われる**ことがあります。

これは「桁あふれ（オーバーフロー）」と呼ばれる現象です。

### 例：

```
64（10進） = 01000000（2進）
↓ << 1（左に1ビットシフト）
→ 10000000（2進） = -128（10進）
```

🧠 本来なら「64 × 2 = 128」のつもりだったのに、  
**8ビットの範囲では128を表せないため、結果が -128 になる！**

→ これは計算ミスではなく、**ビット数の限界による仕様上の“落とし穴”**です。

---

📘 試験や問題集での注意点：

試験や参考書の問題文では、以下のような補足がつくことがあります：

> ※ オーバーフローが発生した場合の動作は考慮しないものとする。

この場合は、**ビット数による符号反転や桁あふれの影響を無視し、  
純粋な「×2」や「÷2」として計算する必要があります。**

📝 つまり、64 << 1 は -128 ではなく **128 を選ぶのが正解になる** ということです！

