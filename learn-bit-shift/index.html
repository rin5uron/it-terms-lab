<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>シフト演算とは？ | ビットシフトを学ぶ</title>
  <link rel="stylesheet" href="styles.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
</head>
<body>

  <header>
    <h1>シフト演算</h1>
    <p>ビットシフトを使い、高速な計算を実現する</p>
  </header>

  <section>
    <div class="summary-box">
      <p>２進数の桁を左右にずらして行う計算手法です。シンプルなので高速に計算できます。</p>
    </div>
    <h2><i class="fas fa-arrows-alt-h"></i> シフト演算とは？</h2>
    <div class="highlight">
      <strong>シフト演算</strong>
      <p>２進数のビット（桁）を左右にずらすことで、<br>2の累乗による掛け算・割り算をシンプルに行う演算手法。</p>
    </div>
    計算がシンプルなのでコンピュータは大量データでも高速に計算できる
  </section>

  <section>
    <div class="summary-box">
      <p>10進数で考えると、桁をずらすことが10倍や1/10倍になるのと同じです。</p>
    </div>
    <h2><i class="fas fa-calculator"></i> 10進数で考えてみる</h2>
    <div class="calculation-box">
<pre>
123 << 1 → 1230（×10）
123 >> 1 → 12.3（÷10）
</pre>
    </div>
    <p>この「桁をずらす＝何倍・何分の1」という感覚を、<br>
    <strong>2進数の世界でも同じように応用する</strong>のが「シフト演算」です。</p>
  </section>

  <section>
    <div class="summary-box">
      <p>シフト演算は、2進数だからこそ成り立ちます。</p>
    </div>
    <h2><i class="fas fa-binary"></i> 2進数でのシフト演算</h2>
    <p>シフト演算は、2進数のビット列を左右にずらす操作をします。<br>
    桁を1つずらす操作は、10進数における「10倍」や「10分の1」の計算に相当します。</p>
    <p>2進数の場合、ビットを1つ左にずらすと値は<strong>2倍</strong>に、右にずらすと<strong>2分の1</strong>になります。</p>

    <div class="calculation-box bit-calculation-box">
      <p><strong>例: 10（2進数: 1010）のシフト演算</strong></p>
<pre>
// 1ビット左シフト (2倍)
1010 &lt;&lt; 1  →  10100 (20)

// 1ビット右シフト (1/2)
1010 &gt;&gt; 1  →  0101 (5)
</pre>
    </div>
    
    <div class="highlight">
      <strong>ポイント</strong><br>
      <p>シフト演算は、コンピュータが最も得意とするビット操作のため、非常に高速です。<br>
      8進数や16進数で表記されることもありますが、実際の計算は必ず2進数で行われます。</p>
    </div>
  </section>

  <section>
    <div class="summary-box">
      <p>論理シフトは、空いた桁に「0」を詰める方法です。負の数には対応していません。</p>
    </div>
    <h2><i class="fas fa-exchange-alt"></i> 論理シフト</h2>
    <p><strong>→ 桁を左右にずらし、空いた桁に「0」を詰める方法。</strong></p>
    <p><strong>左シフトで×2、右シフトで÷2</strong> になります。</p>

    <h3>論理左シフト </h3>
    <p>元の値: 5</p>
    <div class="bit-string-example">
      <span class="bit-box">0</span><span class="bit-box">0</span><span class="bit-box">0</span><span class="bit-box">0</span>
      <span class="bit-box">0</span><span class="bit-box">1</span><span class="bit-box">0</span><span class="bit-box">1</span>
    </div>
    <p class="arrow">↓ 1ビット左シフト</p>
    <div class="bit-string-example shifted">
      <span class="bit-box">0</span><span class="bit-box">0</span><span class="bit-box">0</span><span class="bit-box">0</span>
      <span class="bit-box">1</span><span class="bit-box">0</span><span class="bit-box">1</span><span class="bit-box new-bit">0</span>
    </div>
    <p>結果: 10</p>

    <h3>論理左シフト</h3>
    <p>元の値: 5</p>
    <div class="bit-string-example">
      <span class="bit-box">0</span><span class="bit-box">0</span><span class="bit-box">0</span><span class="bit-box">0</span>
      <span class="bit-box">0</span><span class="bit-box">1</span><span class="bit-box">0</span><span class="bit-box">1</span>
    </div>
    <p class="arrow">↓ 2ビット左シフト</p>
    <div class="bit-string-example shifted">
      <span class="bit-box">0</span><span class="bit-box">0</span><span class="bit-box">0</span><span class="bit-box">1</span>
      <span class="bit-box">0</span><span class="bit-box">1</span><span class="bit-box new-bit">0</span><span class="bit-box new-bit">0</span>
    </div>
    <p>結果: 20</p>

    <h3>論理右シフト</h3>
    <p>元の値: 8</p>
    <div class="bit-string-example">
      <span class="bit-box">0</span><span class="bit-box">0</span><span class="bit-box">0</span><span class="bit-box">0</span>
      <span class="bit-box">1</span><span class="bit-box">0</span><span class="bit-box">0</span><span class="bit-box">0</span>
    </div>
    <p class="arrow">↓ 1ビット右シフト</p>
    <div class="bit-string-example shifted">
      <span class="bit-box new-bit">0</span><span class="bit-box">0</span><span class="bit-box">0</span><span class="bit-box">0</span>
      <span class="bit-box">0</span><span class="bit-box">1</span><span class="bit-box">0</span><span class="bit-box">0</span>
    </div>
    <p>結果: 4</p>

    <h3>論理右シフト</h3>
    <p>元の値: 8</p>
    <div class="bit-string-example">
      <span class="bit-box">0</span><span class="bit-box">0</span><span class="bit-box">0</span><span class="bit-box">0</span>
      <span class="bit-box">1</span><span class="bit-box">0</span><span class="bit-box">0</span><span class="bit-box">0</span>
    </div>
    <p class="arrow">↓ 2ビット右シフト</p>
    <div class="bit-string-example shifted">
      <span class="bit-box new-bit">0</span><span class="bit-box new-bit">0</span><span class="bit-box">0</span><span class="bit-box">0</span>
      <span class="bit-box">0</span><span class="bit-box">0</span><span class="bit-box">1</span><span class="bit-box">0</span>
    </div>
    <p>結果: 2</p>

    <p>※ 論理右シフトでは、常に左端に <strong>0</strong> が入ります。<br>
    ※ 負の数には対応していません。</p>
  </section>

  <section>
    <div class="summary-box">
      <p>算術シフトは、左端の符号ビットを固定したまま右シフトする方法で、負の数も扱えます。</p>
    </div>
    <h2><i class="fas fa-calculator"></i> 算術シフト</h2>
    <p><strong>→ 左端の符号ビットを固定したまま右シフトする方法。</strong></p>
    <ul>
      <li>負の数もそのまま扱えるため、符号付き整数の除算によく用いられます。</li>
      <li>CPUレベルでは「符号付き整数（signed int）」の演算に使われます。</li>
    </ul>

    <h3>算術右シフト</h3>
    <p>元の値: -4</p>
    <div class="bit-string-example">
      <span class="bit-box">1</span><span class="bit-box">1</span><span class="bit-box">1</span><span class="bit-box">1</span>
      <span class="bit-box">1</span><span class="bit-box">1</span><span class="bit-box">0</span><span class="bit-box">0</span>
    </div>
    <p class="arrow">↓ 1ビット算術右シフト</p>
    <div class="bit-string-example shifted">
      <span class="bit-box new-bit">1</span><span class="bit-box">1</span><span class="bit-box">1</span><span class="bit-box">1</span>
      <span class="bit-box">1</span><span class="bit-box">1</span><span class="bit-box">1</span><span class="bit-box">0</span>
    </div>
    <p>結果: -2</p>
  </section>

  <section>
    <div class="summary-box">
      <p>最上位ビットに1が入るとオーバーフロー（桁あふれ）し、負の数になることがあります。</p>
    </div>
    <h2><i class="fas fa-exclamation-triangle"></i> オーバーフロー</h2>
    <p>左シフトは通常「×2」「×4」のように値を大きくしますが、<br>
    <strong>符号付きの整数を左シフトして、最上位ビットに1が入ると、</strong><br>
    <strong>符号が反転して“負の数”として扱われる</strong>ことがあります。</p>
    <p>これは「桁あふれ（オーバーフロー）」と呼ばれる現象です。</p>

    <h3>例：</h3>
    <div class="calculation-box">
<pre>
64（10進） = 01000000（2進）
↓ &lt;&lt; 1（左に1ビットシフト）
→ 10000000（2進） = -128（10進）
</pre>
    </div>
    <p> 本来なら「64 × 2 = 128」のつもりだったのに、<br>
    <strong>8ビットの範囲では128を表せないため、結果が -128 になる！</strong></p>
    <p>→ これは計算ミスではなく、<strong>ビット数の限界による仕様上の“落とし穴”</strong>です。</p>

    <div class="highlight">
      <strong>試験や問題集での注意点：</strong><br>
      <p>試験や参考書の問題文では、以下のような補足がつくことがあります：</p>
      <blockquote class="note-box">※ オーバーフローが発生した場合の動作は考慮しないものとする。</blockquote>
      <p>この場合は、<strong>ビット数による符号反転や桁あふれの影響を無視し、<br>
      純粋な「×2」や「÷2」として計算する必要があります。</strong></p>
      <p>つまり、64 &lt;&lt; 1 は -128 ではなく <strong>128 を選ぶのが正解になる</strong> ということです！</p>
    </div>
    <div class="center">
      <a class="btn-link" href="practice.html">練習問題に挑戦する</a>
    </div>
  </section>

  

  

</body>
</html>